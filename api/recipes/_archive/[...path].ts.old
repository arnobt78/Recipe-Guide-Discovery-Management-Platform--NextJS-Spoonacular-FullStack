/**
 * Consolidated Recipes API Handler (Catch-All Route)
 * 
 * Handles ALL recipe endpoints using Vercel catch-all routing:
 * - /api/recipes/search ‚Üí handled via path[0] === "search"
 * - /api/recipes/autocomplete ‚Üí handled via path[0] === "autocomplete"
 * - /api/recipes/favourite ‚Üí handled via path[0] === "favourite"
 * - /api/recipes/[recipeId]/information ‚Üí handled by [recipeId]/information.ts (specific route)
 * - /api/recipes/[recipeId]/similar ‚Üí handled by [recipeId]/similar.ts (specific route)
 * - /api/recipes/[recipeId]/summary ‚Üí handled by [recipeId]/summary.ts (specific route)
 * 
 * All original code preserved, consolidated to reduce serverless function count.
 * Frontend calls remain exactly the same - no changes needed.
 */

import "dotenv/config";
import { VercelRequest, VercelResponse } from "@vercel/node";
import { searchRecipes, autocompleteRecipes } from "../../lib/recipe-api.js";
import { prisma } from "../../lib/prisma.js";
import { getFavouriteRecipesByIDs } from "../../lib/recipe-api.js";
import {
  setCorsHeaders,
  handleCorsPreflight,
  requireAuth,
} from "../../lib/api-utils.js";

export default async function handler(
  request: VercelRequest,
  response: VercelResponse
) {
  // CRITICAL: Log EVERY request to see what's being routed
  // This helps debug why numeric recipe IDs aren't being handled
  console.log("üöÄ [Recipes API] Handler called:", {
    method: request.method,
    url: request.url,
    "query.path": request.query.path,
    "query": request.query,
    "headers.host": request.headers.host,
  });
  
  // Handle CORS preflight
  if (handleCorsPreflight(request, response)) {
    return;
  }

  setCorsHeaders(response);

  // Extract path segments from catch-all route parameter
  // In Vercel, catch-all routes [...path] put segments in request.query.path as array or string
  // When running from parent directory, path extraction may need special handling
  let pathArray: string[] = [];
  
  // DEBUG: Log all path-related information
  console.log("üîç [Recipes API] Path extraction debug:", {
    "request.url": request.url,
    "request.query.path": request.query.path,
    "request.query.path type": typeof request.query.path,
    "request.query.path isArray": Array.isArray(request.query.path),
    "request.headers.host": request.headers.host,
    "request.headers['x-forwarded-host']": request.headers["x-forwarded-host"],
    "request.headers['x-forwarded-proto']": request.headers["x-forwarded-proto"],
  });
  
  // Method 1: Use request.query.path (Vercel's catch-all route parameter)
  // This is the PRIMARY method - Vercel should populate this for [...path] routes
  const pathParam = request.query.path;
  if (pathParam) {
    if (Array.isArray(pathParam)) {
      pathArray = pathParam;
      console.log("‚úÖ [Recipes API] Path from query.path (array):", pathArray);
    } else if (typeof pathParam === "string") {
      // Handle both "/" separated strings and comma-separated strings
      pathArray = pathParam.includes("/") 
        ? pathParam.split("/").filter(Boolean)
        : pathParam.split(",").filter(Boolean);
      console.log("‚úÖ [Recipes API] Path from query.path (string):", pathArray);
    }
  }
  
  // Method 2: Extract from URL pathname if query.path didn't work or is empty
  // This handles cases where Vercel doesn't populate query.path correctly
  // CRITICAL: When running from parent directory, request.url might be different
  if (pathArray.length === 0 && request.url) {
    try {
      // Vercel provides request.url which may be relative or absolute
      let url: URL;
      
      // Handle absolute URLs
      if (request.url.startsWith("http://") || request.url.startsWith("https://")) {
        url = new URL(request.url);
      } else {
        // For relative URLs, construct full URL using Vercel headers
        const protocol = request.headers["x-forwarded-proto"] || "http";
        const host = request.headers.host || request.headers["x-forwarded-host"] || "localhost:3001";
        url = new URL(request.url, `${protocol}://${host}`);
      }
      
      console.log("üîç [Recipes API] Parsed URL:", {
        pathname: url.pathname,
        search: url.search,
        fullUrl: url.toString(),
      });
      
      // Extract path segments after /api/recipes
      // Handle both /api/recipes/... and /frontend-serverless/api/recipes/... patterns
      const segments = url.pathname.split("/").filter(Boolean);
      let recipesIndex = segments.indexOf("recipes");
      
      // If recipes not found, try looking for it after "api"
      if (recipesIndex === -1) {
        const apiIndex = segments.indexOf("api");
        if (apiIndex !== -1 && apiIndex < segments.length - 1) {
          // Check if next segment is "recipes"
          if (segments[apiIndex + 1] === "recipes") {
            recipesIndex = apiIndex + 1;
          }
        }
      }
      
      if (recipesIndex !== -1 && recipesIndex < segments.length - 1) {
        pathArray = segments.slice(recipesIndex + 1);
        console.log("‚úÖ [Recipes API] Path from URL pathname:", pathArray);
      } else {
        console.log("‚ö†Ô∏è [Recipes API] Could not find 'recipes' in pathname segments:", segments);
      }
    } catch (error) {
      console.error("‚ùå [Recipes API] URL parsing error:", error);
    }
  }
  
  // Method 3: Try extracting from request.url directly using regex (last resort)
  // This handles edge cases where URL format is non-standard
  if (pathArray.length === 0 && request.url) {
    const urlStr = typeof request.url === "string" ? request.url : String(request.url);
    
    // Try multiple patterns to match different URL formats
    // Pattern 1: /api/recipes/716426/information
    // Pattern 2: /frontend-serverless/api/recipes/716426/information
    // Pattern 3: /recipes/716426/information (if /api was stripped)
    let match = urlStr.match(/(?:^|\/)(?:frontend-serverless\/)?api\/recipes\/(.+?)(?:\?|$)/);
    if (!match) {
      // Try without /api prefix (in case it was stripped)
      match = urlStr.match(/\/recipes\/(.+?)(?:\?|$)/);
    }
    if (!match) {
      // Try matching just the path segments after any /recipes/
      match = urlStr.match(/recipes\/(.+?)(?:\?|$)/);
    }
    
    if (match && match[1]) {
      pathArray = match[1].split("/").filter(Boolean);
      console.log("‚úÖ [Recipes API] Path from regex extraction:", pathArray);
    } else {
      console.log("‚ö†Ô∏è [Recipes API] Regex extraction failed for URL:", request.url);
    }
  }
  
  // Final check: If still no path, try one more method - check if path is in the URL directly
  if (pathArray.length === 0 && request.url) {
    // Try to extract from the raw URL string - handle various formats
    const urlStr = typeof request.url === "string" ? request.url : String(request.url);
    
    // Pattern: /api/recipes/716426/information or /recipes/716426/information
    const recipesMatch = urlStr.match(/\/recipes\/([^?]+)/);
    if (recipesMatch && recipesMatch[1]) {
      pathArray = recipesMatch[1].split("/").filter(Boolean);
      console.log("‚úÖ [Recipes API] Path from URL regex (final fallback):", pathArray);
    }
  }
  
  // Final check: If still no path, log error
  if (pathArray.length === 0) {
    console.error("‚ùå [Recipes API] Failed to extract path from request:", {
      url: request.url,
      query: request.query,
      "query.path": request.query.path,
      headers: {
        host: request.headers.host,
        "x-forwarded-host": request.headers["x-forwarded-host"],
      },
    });
    return response.status(500).json({ 
      error: "Internal server error: Could not extract path from request",
      debug: {
        url: request.url,
        query: request.query,
      }
    });
  }

  const firstSegment = pathArray[0] || "";
  const secondSegment = pathArray[1] || "";
  
  console.log("üìã [Recipes API] Final path segments:", {
    firstSegment,
    secondSegment,
    fullPath: pathArray,
    "firstSegment isNumeric": firstSegment ? /^\d+$/.test(firstSegment) : false,
  });
  
  // IMPORTANT: If first segment is numeric (recipeId), let specific routes handle it
  // Specific routes at [recipeId]/information.ts, [recipeId]/similar.ts, [recipeId]/summary.ts
  // This prevents routing conflicts with the catch-all route
  if (firstSegment && /^\d+$/.test(firstSegment)) {
    console.log("‚ö†Ô∏è [Recipes API] Numeric recipeId detected, should be handled by specific [recipeId] routes");
    return response.status(404).json({ error: "Endpoint not found" });
  }

  // Handle action endpoints (search, autocomplete, favourite)
  const endpoint = firstSegment;

  try {
    // Handle /api/recipes/search
    if (endpoint === "search" && request.method === "GET") {
      const searchTerm = (request.query.searchTerm as string) || "";
      const page = parseInt((request.query.page as string) || "0", 10);

      // Extract optional search parameters (comprehensive support for all API parameters)
      const searchOptions: Parameters<typeof searchRecipes>[2] = {
        fillIngredients: request.query.fillIngredients === "true",
        addRecipeInformation: request.query.addRecipeInformation === "true",
        addRecipeInstructions: request.query.addRecipeInstructions === "true",
        addRecipeNutrition: request.query.addRecipeNutrition === "true",
        cuisine: request.query.cuisine as string | undefined,
        excludeCuisine: request.query.excludeCuisine as string | undefined,
        diet: request.query.diet as string | undefined,
        intolerances: request.query.intolerances as string | undefined,
        equipment: request.query.equipment as string | undefined,
        includeIngredients: request.query.includeIngredients as
          | string
          | undefined,
        excludeIngredients: request.query.excludeIngredients as
          | string
          | undefined,
        type: request.query.type as string | undefined,
        instructionsRequired: request.query.instructionsRequired === "true",
        maxReadyTime: request.query.maxReadyTime
          ? parseInt(request.query.maxReadyTime as string, 10)
          : undefined,
        minServings: request.query.minServings
          ? parseInt(request.query.minServings as string, 10)
          : undefined,
        maxServings: request.query.maxServings
          ? parseInt(request.query.maxServings as string, 10)
          : undefined,
        ignorePantry: request.query.ignorePantry === "true",
        sort: request.query.sort as string | undefined,
        sortDirection: request.query.sortDirection as
          | "asc"
          | "desc"
          | undefined,
        minCalories: request.query.minCalories
          ? parseInt(request.query.minCalories as string, 10)
          : undefined,
        maxCalories: request.query.maxCalories
          ? parseInt(request.query.maxCalories as string, 10)
          : undefined,
        minProtein: request.query.minProtein
          ? parseInt(request.query.minProtein as string, 10)
          : undefined,
        maxProtein: request.query.maxProtein
          ? parseInt(request.query.maxProtein as string, 10)
          : undefined,
        minCarbs: request.query.minCarbs
          ? parseInt(request.query.minCarbs as string, 10)
          : undefined,
        maxCarbs: request.query.maxCarbs
          ? parseInt(request.query.maxCarbs as string, 10)
          : undefined,
        minFat: request.query.minFat
          ? parseInt(request.query.minFat as string, 10)
          : undefined,
        maxFat: request.query.maxFat
          ? parseInt(request.query.maxFat as string, 10)
          : undefined,
        minAlcohol: request.query.minAlcohol
          ? parseInt(request.query.minAlcohol as string, 10)
          : undefined,
        maxAlcohol: request.query.maxAlcohol
          ? parseInt(request.query.maxAlcohol as string, 10)
          : undefined,
        minCaffeine: request.query.minCaffeine
          ? parseInt(request.query.minCaffeine as string, 10)
          : undefined,
        maxCaffeine: request.query.maxCaffeine
          ? parseInt(request.query.maxCaffeine as string, 10)
          : undefined,
        minCopper: request.query.minCopper
          ? parseInt(request.query.minCopper as string, 10)
          : undefined,
        maxCopper: request.query.maxCopper
          ? parseInt(request.query.maxCopper as string, 10)
          : undefined,
        minCalcium: request.query.minCalcium
          ? parseInt(request.query.minCalcium as string, 10)
          : undefined,
        maxCalcium: request.query.maxCalcium
          ? parseInt(request.query.maxCalcium as string, 10)
          : undefined,
        minCholine: request.query.minCholine
          ? parseInt(request.query.minCholine as string, 10)
          : undefined,
        maxCholine: request.query.maxCholine
          ? parseInt(request.query.maxCholine as string, 10)
          : undefined,
        minCholesterol: request.query.minCholesterol
          ? parseInt(request.query.minCholesterol as string, 10)
          : undefined,
        maxCholesterol: request.query.maxCholesterol
          ? parseInt(request.query.maxCholesterol as string, 10)
          : undefined,
        minFluoride: request.query.minFluoride
          ? parseInt(request.query.minFluoride as string, 10)
          : undefined,
        maxFluoride: request.query.maxFluoride
          ? parseInt(request.query.maxFluoride as string, 10)
          : undefined,
        minSaturatedFat: request.query.minSaturatedFat
          ? parseInt(request.query.minSaturatedFat as string, 10)
          : undefined,
        maxSaturatedFat: request.query.maxSaturatedFat
          ? parseInt(request.query.maxSaturatedFat as string, 10)
          : undefined,
        minVitaminA: request.query.minVitaminA
          ? parseInt(request.query.minVitaminA as string, 10)
          : undefined,
        maxVitaminA: request.query.maxVitaminA
          ? parseInt(request.query.maxVitaminA as string, 10)
          : undefined,
        minVitaminC: request.query.minVitaminC
          ? parseInt(request.query.minVitaminC as string, 10)
          : undefined,
        maxVitaminC: request.query.maxVitaminC
          ? parseInt(request.query.maxVitaminC as string, 10)
          : undefined,
        minVitaminD: request.query.minVitaminD
          ? parseInt(request.query.minVitaminD as string, 10)
          : undefined,
        maxVitaminD: request.query.maxVitaminD
          ? parseInt(request.query.maxVitaminD as string, 10)
          : undefined,
        minVitaminE: request.query.minVitaminE
          ? parseInt(request.query.minVitaminE as string, 10)
          : undefined,
        maxVitaminE: request.query.maxVitaminE
          ? parseInt(request.query.maxVitaminE as string, 10)
          : undefined,
        minVitaminK: request.query.minVitaminK
          ? parseInt(request.query.minVitaminK as string, 10)
          : undefined,
        maxVitaminK: request.query.maxVitaminK
          ? parseInt(request.query.maxVitaminK as string, 10)
          : undefined,
        minVitaminB1: request.query.minVitaminB1
          ? parseInt(request.query.minVitaminB1 as string, 10)
          : undefined,
        maxVitaminB1: request.query.maxVitaminB1
          ? parseInt(request.query.maxVitaminB1 as string, 10)
          : undefined,
        minVitaminB2: request.query.minVitaminB2
          ? parseInt(request.query.minVitaminB2 as string, 10)
          : undefined,
        maxVitaminB2: request.query.maxVitaminB2
          ? parseInt(request.query.maxVitaminB2 as string, 10)
          : undefined,
        minVitaminB5: request.query.minVitaminB5
          ? parseInt(request.query.minVitaminB5 as string, 10)
          : undefined,
        maxVitaminB5: request.query.maxVitaminB5
          ? parseInt(request.query.maxVitaminB5 as string, 10)
          : undefined,
        minVitaminB3: request.query.minVitaminB3
          ? parseInt(request.query.minVitaminB3 as string, 10)
          : undefined,
        maxVitaminB3: request.query.maxVitaminB3
          ? parseInt(request.query.maxVitaminB3 as string, 10)
          : undefined,
        minVitaminB6: request.query.minVitaminB6
          ? parseInt(request.query.minVitaminB6 as string, 10)
          : undefined,
        maxVitaminB6: request.query.maxVitaminB6
          ? parseInt(request.query.maxVitaminB6 as string, 10)
          : undefined,
        minVitaminB12: request.query.minVitaminB12
          ? parseInt(request.query.minVitaminB12 as string, 10)
          : undefined,
        maxVitaminB12: request.query.maxVitaminB12
          ? parseInt(request.query.maxVitaminB12 as string, 10)
          : undefined,
        minFiber: request.query.minFiber
          ? parseInt(request.query.minFiber as string, 10)
          : undefined,
        maxFiber: request.query.maxFiber
          ? parseInt(request.query.maxFiber as string, 10)
          : undefined,
        minFolate: request.query.minFolate
          ? parseInt(request.query.minFolate as string, 10)
          : undefined,
        maxFolate: request.query.maxFolate
          ? parseInt(request.query.maxFolate as string, 10)
          : undefined,
        minFolicAcid: request.query.minFolicAcid
          ? parseInt(request.query.minFolicAcid as string, 10)
          : undefined,
        maxFolicAcid: request.query.maxFolicAcid
          ? parseInt(request.query.maxFolicAcid as string, 10)
          : undefined,
        minIodine: request.query.minIodine
          ? parseInt(request.query.minIodine as string, 10)
          : undefined,
        maxIodine: request.query.maxIodine
          ? parseInt(request.query.maxIodine as string, 10)
          : undefined,
        minIron: request.query.minIron
          ? parseInt(request.query.minIron as string, 10)
          : undefined,
        maxIron: request.query.maxIron
          ? parseInt(request.query.maxIron as string, 10)
          : undefined,
        minMagnesium: request.query.minMagnesium
          ? parseInt(request.query.minMagnesium as string, 10)
          : undefined,
        maxMagnesium: request.query.maxMagnesium
          ? parseInt(request.query.maxMagnesium as string, 10)
          : undefined,
        minManganese: request.query.minManganese
          ? parseInt(request.query.minManganese as string, 10)
          : undefined,
        maxManganese: request.query.maxManganese
          ? parseInt(request.query.maxManganese as string, 10)
          : undefined,
        minPhosphorus: request.query.minPhosphorus
          ? parseInt(request.query.minPhosphorus as string, 10)
          : undefined,
        maxPhosphorus: request.query.maxPhosphorus
          ? parseInt(request.query.maxPhosphorus as string, 10)
          : undefined,
        minPotassium: request.query.minPotassium
          ? parseInt(request.query.minPotassium as string, 10)
          : undefined,
        maxPotassium: request.query.maxPotassium
          ? parseInt(request.query.maxPotassium as string, 10)
          : undefined,
        minSelenium: request.query.minSelenium
          ? parseInt(request.query.minSelenium as string, 10)
          : undefined,
        maxSelenium: request.query.maxSelenium
          ? parseInt(request.query.maxSelenium as string, 10)
          : undefined,
        minSodium: request.query.minSodium
          ? parseInt(request.query.minSodium as string, 10)
          : undefined,
        maxSodium: request.query.maxSodium
          ? parseInt(request.query.maxSodium as string, 10)
          : undefined,
        minSugar: request.query.minSugar
          ? parseInt(request.query.minSugar as string, 10)
          : undefined,
        maxSugar: request.query.maxSugar
          ? parseInt(request.query.maxSugar as string, 10)
          : undefined,
        minZinc: request.query.minZinc
          ? parseInt(request.query.minZinc as string, 10)
          : undefined,
        maxZinc: request.query.maxZinc
          ? parseInt(request.query.maxZinc as string, 10)
          : undefined,
        author: request.query.author as string | undefined,
        tags: request.query.tags as string | undefined,
        recipeBoxId: request.query.recipeBoxId
          ? parseInt(request.query.recipeBoxId as string, 10)
          : undefined,
        titleMatch: request.query.titleMatch as string | undefined,
      };

      // Remove undefined values
      const cleanOptions = Object.fromEntries(
        Object.entries(searchOptions).filter(([_, v]) => v !== undefined)
      );

      const results = await searchRecipes(
        searchTerm,
        page,
        Object.keys(cleanOptions).length > 0 ? cleanOptions : undefined
      );

      return response.status(200).json(results);
    }

    // Handle /api/recipes/autocomplete
    if (endpoint === "autocomplete" && request.method === "GET") {
      const query = request.query.query as string;
      const number = request.query.number
        ? parseInt(request.query.number as string, 10)
        : 10;

      if (!query || query.trim().length < 2) {
        return response
          .status(400)
          .json({ error: "Query must be at least 2 characters" });
      }

      if (isNaN(number) || number < 1 || number > 25) {
        return response
          .status(400)
          .json({ error: "Number must be between 1 and 25" });
      }

      const results = await autocompleteRecipes(query, number);

      return response.status(200).json(results);
    }

    // Handle /api/recipes/favourite
    if (endpoint === "favourite") {
      // POST: Add favorite recipe
      if (request.method === "POST") {
        const userId = await requireAuth(request, response);
        if (!userId) {
          return;
        }

        const { recipeId } = request.body;

        if (!recipeId) {
          return response.status(400).json({ error: "Recipe ID is required" });
        }

        const existing = await prisma.favouriteRecipes.findFirst({
          where: {
            recipeId: Number(recipeId),
            userId: userId,
          },
        });

        if (existing) {
          return response.status(409).json({
            error: "Recipe is already in favorites",
          });
        }

        try {
          const favouriteRecipe = await prisma.favouriteRecipes.create({
            data: {
              recipeId: Number(recipeId),
              userId: userId,
            },
            select: {
              id: true,
              recipeId: true,
              userId: true,
            },
          });

          return response.status(201).json(favouriteRecipe);
        } catch (createError: unknown) {
          const error = createError as Error;
          if (
            error.message.includes("createdAt") ||
            error.message.includes("does not exist")
          ) {
            console.warn("‚ö†Ô∏è [Favourite API] Database schema mismatch");

            return response.status(500).json({
              error: "Database schema needs migration",
              message:
                "Please run: npx prisma migrate deploy or npx prisma db push",
              details: error.message,
            });
          }
          throw createError;
        }
      }

      // GET: Get all favorite recipes
      if (request.method === "GET") {
        const userId = await requireAuth(request, response);
        if (!userId) {
          return;
        }

        const recipes = await prisma.favouriteRecipes.findMany({
          where: {
            userId: userId,
          },
          select: {
            recipeId: true,
          },
        });
        const recipeIds = recipes.map((recipe) => recipe.recipeId.toString());

        if (recipeIds.length === 0) {
          return response.status(200).json({ results: [] });
        }

        try {
          const favourites = await getFavouriteRecipesByIDs(recipeIds);
          return response.status(200).json(favourites);
        } catch (apiError: unknown) {
          const error = apiError as { code?: number; message?: string };
          const isApiLimitError =
            error?.code === 402 ||
            error?.message?.includes("points limit") ||
            error?.message?.includes("daily limit");

          if (isApiLimitError) {
            console.warn(
              "‚ö†Ô∏è [Favourite API] Spoonacular API daily limit reached."
            );

            return response.status(200).json({
              results: recipeIds.map((id) => ({
                id: parseInt(id),
                title: `Recipe #${id} (Details unavailable - API limit reached)`,
                image: null,
                _apiUnavailable: true,
              })),
              _message:
                "Your favourites are saved, but recipe details are temporarily unavailable due to API daily limit.",
            });
          }

          throw apiError;
        }
      }

      // DELETE: Remove favorite recipe
      if (request.method === "DELETE") {
        const userId = await requireAuth(request, response);
        if (!userId) {
          return;
        }

        const { recipeId } = request.body;

        if (!recipeId) {
          return response.status(400).json({ error: "Recipe ID is required" });
        }

        try {
          // Find the record first using the compound unique constraint
          const existing = await prisma.favouriteRecipes.findFirst({
            where: {
              recipeId: Number(recipeId),
              userId: userId,
            },
          });

          // Delete by id if found
          if (existing) {
            await prisma.favouriteRecipes.delete({
              where: {
                id: existing.id,
              },
            });
          }
        } catch (deleteError: unknown) {
          const error = deleteError as { code?: string };
          if (error.code !== "P2025") {
            throw deleteError;
          }
        }

        return response.status(204).end();
      }
    }

    // Method not allowed or endpoint not found
    if (
      request.method !== "GET" &&
      request.method !== "POST" &&
      request.method !== "DELETE"
    ) {
      return response.status(405).json({ error: "Method not allowed" });
    }

    // DEBUG: Log why endpoint wasn't found
    console.error("‚ùå [Recipes API] Endpoint not found:", {
      endpoint: firstSegment,
      pathArray,
      method: request.method,
      url: request.url,
      "query.path": request.query.path,
    });
    
    return response.status(404).json({ 
      error: "Endpoint not found",
      debug: {
        endpoint: firstSegment,
        pathArray,
        method: request.method,
      }
    });
  } catch (error) {
    console.error("‚ùå [Recipes Consolidated API] Error:", error);
    console.error(
      "‚ùå [Recipes Consolidated API] Error type:",
      error instanceof Error ? error.constructor.name : typeof error
    );
    console.error(
      "‚ùå [Recipes Consolidated API] Error message:",
      error instanceof Error ? error.message : String(error)
    );

    if (error instanceof Error) {
      console.error("‚ùå [Recipes Consolidated API] Error stack:", error.stack);
    }

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    const statusCode =
      errorMessage.includes("limit") || errorMessage.includes("402")
        ? 402
        : 500;

    if (error instanceof Error && error.message.includes("Unique constraint")) {
      return response.status(409).json({
        error: "Recipe is already in favorites",
      });
    }

    return response.status(statusCode).json({
      error: "Internal server error",
      message: errorMessage,
    });
  }
}
